import { Fragment } from "react";
import fs from "fs/promises";
import path from "path";

function ProductDetailPage(props) {
    const {loadedProduct} = props;
    

  return (
    <Fragment>
      <h1>{loadedProduct.title}</h1>
      <p>{loadedProduct.description}</p>
    </Fragment>
  );
}
/*
I want to read the file and only return one product from that file.That will be the 
difference. And therefore of course we need to know which product should be returned here.

And of course, that's something we can determine by looking at the concrete value, 
which is in the URL. So to concrete value for this PID key here. That's where does context 
parameter again becomes important because I did briefly mention before
that we can use this context parameter, which is exposed to us buying Next.js,
to get hold of the concrete param values. So the concrete values for these dynamic segments
in our paths. We do get access to that by having a look at the params key in context.

Of course, you can also extract params through the use router hook inside of the component 
function.Now there is a difference between extracting params in the component function 
and the getStaticProps. 

When we extract these params in the component function,we can use them inside of the 
component, for example to use that extracted ID to send a request to some backend server
to fetch data from there, but that would then only happen in the browser. 
If you want to pre-render a page with help of getStaticProps,
which we use to prepare the data for pre-rendering the page,
then this happens on the server.

And as I explained, getStaticProps runs before the component function runs.
It needs to run before that because the component function is then executed to 
pre-render the page.
*/

export async function getStaticProps(context) {
  const { params } = context;
  const productId = params.pid;

  const filePath = path.join(process.cwd(), "data", "dummy-backend.json");
  const jsonData = await fs.readFile(filePath);
  const data = JSON.parse(jsonData);

  const product = data.products.find((product) => product.id === productId);

  return {
    props :{
        loadedProduct: product
    }
  }
}


/*
When you run the app you'll get the error - 
Error: getStaticPaths is required for dynamic SSG pages and is missing for '/[pid]'.

Next.js is pre-generating all the pages.And I mentioned that it would pre-generate pages 
by default. It turns out this is not the case if you have a dynamic page,so where the 
name of the component has such square brackets.

If you have a dynamic segment leading to that page, if you have that, the default behavior 
is not to pre-generate the page. And why is that not the default, because keep in mind that 
technically for a this page, we won't just have one page, but multiple pages for different 
IDs,

That's why for such dynamic routes,we need to give Next.js more information.
We can also tell Next.js which paths. So which instances off a dynamic page should be 
pre-generated. Because here we don't just need data we also need to let Next.js know which 
ID values,which dynamic segment values will be available and for which values a page should 
be pre-generated. So that multiple instances of that page blueprint
can be pre-generated by Next.js.

So another function we can add in this page file, - getStaticPaths function,
which also is a async. So where you can also use the await keyword and just ask get static 
props.
*/


/*
Now this tells Next.js that this dynamic page here should be pre-generated three times with 
these three values as a value for this dynamic segment identifier.And then Next.js will 
call getStaticProps three timesfor these different ideas.

And we then can extract that ID like this inside of this function. Now for this to work,we 
also need to add another key next to paths,and that's the fallback key,
*/
export async function getStaticPaths(){
    /*
     this should return an object,just as getStaticProps does, but an object with different 
     kinds of values.An object where you have a paths key.And that's now an array, an array 
     full of objects. 
     So that is a given structure, which you must return here.
     Now in this object, you must add a params key now, and that holds another object
     where you have a bunch of key value pairs where the keys are all the different
     dynamic segment identifiers that might lead to this page. If that would be nested 
     deeper in a folder where the folder name is also dynamic,you could have multiple 
     identifiers.
    */
    return {
        paths:[
            {params: {pid : 'p1'} },
            {params: {pid:  'p2'} },
            {params: {pid:  'p3'} },
        ],
        fallback: false
    }
}

export default ProductDetailPage;
